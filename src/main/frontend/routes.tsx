/******************************************************************************
 * This file is auto-generated by Vaadin.
 * It configures React Router automatically by looking for React views files,
 * located in `src/main/frontend/views/` directory.
 * A manual configuration can be done as well, you have to:
 * - copy this file or create your own `routes.tsx` in your frontend directory,
 *   then modify this copied/created file. By default, the `routes.tsx` file
 *   should be in `src/main/frontend/` folder;
 * - use `RouterConfigurationBuilder` API to configure routes for the application;
 * - restart the application, so that the imports get re-generated.
 *
 * `RouterConfigurationBuilder` combines a File System-based route configuration
 * or your explicit routes configuration with the server-side routes.
 *
 * It has the following methods:
 * - `withFileRoutes` enables the File System-based routes autoconfiguration;
 * - `withReactRoutes` adds manual explicit route hierarchy. Allows also to add
 * an individual route, which then merged into File System-based routes,
 * e.g. Log In view;
 * - `withFallback` adds a given component, e.g. server-side routes,
 * to each branch of the current list of routes;
 * - `protect` optional method that adds an authentication later to the routes.
 * May be used with no parameters or with a path to redirect to, if the user is
 * not authenticated.
 * - `build` terminal build operation that returns the final routes array
 * RouterObject[] and router object.
 *
 * NOTE:
 * - You need to restart the dev-server after adding the new `routes.tsx` file.
 * After that, all modifications to `routes.tsx` are recompiled automatically.
 * - You may need to change a routes import in `index.tsx`, if `index.tsx`
 * exists in the frontend folder (not in generated folder) and you copied the file,
 * as the import isn't updated automatically by Vaadin in this case.
 ******************************************************************************/
import { RouterConfigurationBuilder as OriginalRouterConfigurationBuilder } from '@vaadin/hilla-file-router/runtime.js';
// import { RouterConfigurationBuilder } from '@vaadin/hilla-file-router/runtime.js';
// Bypass Flow exception:
import Flow from 'Frontend/generated/flow/Flow';
import fileRoutes from 'Frontend/generated/file-routes';
import {createBrowserRouter, RouteObject} from 'react-router-dom';
import type { RouterBuildOptions, RouterConfiguration } from '@vaadin/hilla-file-router/types.js';
import {ComponentType, createElement} from "react";

type RouteModifier = (routes: readonly RouteObject[]) => readonly RouteObject[];


class RouterConfigurationBuilder extends OriginalRouterConfigurationBuilder {
  #modifiers: RouteModifier[] = [];

  withLayouts(layoutComponent: ComponentType) {
    function applyLayouts(routes: readonly RouteObject[]): readonly RouteObject[] {
      const nestedRoutes = routes.map((route) => {
        if (route.children === undefined || route.index) {
          return route;
        }

        return {
          ...route,
          children: applyLayouts(route.children),
        } as RouteObject;
      });
        return [{
          element: createElement(layoutComponent),
          children: nestedRoutes,
        }];
    }

    this.#modifiers.push((routes: readonly RouteObject[]) => {
        if(!routes) {
            return routes;
        }
        const withLayout = routes.filter(
            (route) => typeof route.handle === 'object' && 'flowLayout' in route.handle && route.handle.flowLayout
        );
        const allRoutes = routes.filter((route) => !withLayout.includes(route));
        // !route.handle || !route.handle.flowLayout);
        withLayout.push(routes[routes.length - 1]); // Add * fallback to all child routes

        allRoutes.unshift(...applyLayouts(withLayout));
        return allRoutes;
    });

    return this;
  }

  build(options?: RouterBuildOptions): RouterConfiguration {
    const {routes: superRoutes, router: superRouter} = super.build(options);

    const routes = this.#modifiers.reduce<readonly RouteObject[]>((acc, mod) => mod(acc) ?? acc, superRoutes) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options }),
    };
  }
}

export const { router, routes } = ((Flow) =>

  new RouterConfigurationBuilder()
    .withFileRoutes(fileRoutes) // (1)

    // @Layout automatically defines server layout matching available routes for the current user
    .withLayouts(Flow)

    .withFallback(Flow)
    .protect()
    .build()

)(Flow);
