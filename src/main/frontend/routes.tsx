/******************************************************************************
 * This file is auto-generated by Vaadin.
 * It configures React Router automatically by looking for React views files,
 * located in `src/main/frontend/views/` directory.
 * A manual configuration can be done as well, you have to:
 * - copy this file or create your own `routes.tsx` in your frontend directory,
 *   then modify this copied/created file. By default, the `routes.tsx` file
 *   should be in `src/main/frontend/` folder;
 * - use `RouterConfigurationBuilder` API to configure routes for the application;
 * - restart the application, so that the imports get re-generated.
 *
 * `RouterConfigurationBuilder` combines a File System-based route configuration
 * or your explicit routes configuration with the server-side routes.
 *
 * It has the following methods:
 * - `withFileRoutes` enables the File System-based routes autoconfiguration;
 * - `withReactRoutes` adds manual explicit route hierarchy. Allows also to add
 * an individual route, which then merged into File System-based routes,
 * e.g. Log In view;
 * - `withFallback` adds a given component, e.g. server-side routes,
 * to each branch of the current list of routes;
 * - `protect` optional method that adds an authentication later to the routes.
 * May be used with no parameters or with a path to redirect to, if the user is
 * not authenticated.
 * - `build` terminal build operation that returns the final routes array
 * RouterObject[] and router object.
 *
 * NOTE:
 * - You need to restart the dev-server after adding the new `routes.tsx` file.
 * After that, all modifications to `routes.tsx` are recompiled automatically.
 * - You may need to change a routes import in `index.tsx`, if `index.tsx`
 * exists in the frontend folder (not in generated folder) and you copied the file,
 * as the import isn't updated automatically by Vaadin in this case.
 ******************************************************************************/
import { RouterConfigurationBuilder as OriginalRouterConfigurationBuilder } from '@vaadin/hilla-file-router/runtime.js';
// Bypass Flow exception:
import Flow from 'Frontend/generated/flow/Flow';
import fileRoutes from 'Frontend/generated/file-routes';
import {createBrowserRouter, RouteObject} from 'react-router-dom';
import type { RouterBuildOptions, RouterConfiguration } from '@vaadin/hilla-file-router/types.js';
import {ComponentType, createElement} from "react";

type RouteModifier = (routes: readonly RouteObject[]) => readonly RouteObject[];


class RouterConfigurationBuilder extends OriginalRouterConfigurationBuilder {
  #modifiers: RouteModifier[] = [];

  withLayouts(paths: readonly string[], layoutComponent: ComponentType) {
    const pathSet = new Set(paths);

    function applyLayouts(contextPath: string, routes: readonly RouteObject[]): readonly RouteObject[] {
      const nestedRoutes = routes.map((route) => {
        if (route.children === undefined || route.index) {
          return route;
        }

        const childPath = route.path
          ? route.path.startsWith('/') ? route.path : `/${route.path}`
          : '';
        const childContextPath = `${contextPath}${childPath}`;
        return {
          ...route,
          children: applyLayouts(childContextPath, route.children),
        } as RouteObject;
      });
      if (pathSet.has(contextPath)) {
        return [{
          element: createElement(layoutComponent),
          children: nestedRoutes,
        }];
      } else {
        return nestedRoutes;
      }
    }

    this.#modifiers.push((routes: readonly RouteObject[]) => {
      return applyLayouts('', routes);
    });

    return this;
  }

  build(options?: RouterBuildOptions): RouterConfiguration {
    const {routes: superRoutes, router: superRouter} = super.build(options);
    let withLayout = superRoutes.filter(route => route.handle && route.handle.layout !== undefined);
    let withoutLayout = superRoutes.filter(route => !route.handle || route.handle.layout === undefined);
    withLayout.push(superRoutes[superRoutes.length-1]); // Add * fallback to all child routes
    const modifiedRoutes = this.#modifiers.reduce<readonly RouteObject[]>((acc, mod) => mod(acc) ?? acc, withLayout) ?? [];
    withoutLayout.unshift(...modifiedRoutes);
    return {
      routes: withoutLayout,
      router: createBrowserRouter([...withoutLayout], { basename: new URL(document.baseURI).pathname, ...options }),
    };
  }
}

export const { router, routes } = ((Flow) =>

  new RouterConfigurationBuilder()
    .withFileRoutes(fileRoutes) // (1)
    //...

    // TODO: automatically use paths from @Layout matching available routes for the current user
    .withLayouts([''], Flow)

    .withFallback(Flow)
    .protect()
    .build()

)(Flow);
